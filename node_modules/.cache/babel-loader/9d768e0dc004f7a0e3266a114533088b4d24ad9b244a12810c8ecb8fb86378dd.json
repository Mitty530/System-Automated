{"ast":null,"code":"import { supabase } from './supabase';\n// Audit Trail Service for comprehensive logging\nexport class AuditTrailService {\n  // Initialize audit trail for user session\n  static initialize(userId, sessionId) {\n    this.currentUserId = userId;\n    this.sessionId = sessionId;\n\n    // Log session start\n    this.logUserActivity('login', 'User logged into the system', {\n      session_id: sessionId,\n      login_timestamp: new Date().toISOString()\n    });\n\n    // Set up page visibility change listener\n    this.setupPageVisibilityListener();\n\n    // Set up beforeunload listener for logout tracking\n    this.setupBeforeUnloadListener();\n  }\n\n  // Core audit logging method\n  static async logAuditEvent(auditData) {\n    // Temporarily disable audit logging until database is set up\n    if (process.env.NODE_ENV === 'development') {\n      console.log('üîç Audit event (disabled):', auditData.action_type, auditData.action_details);\n      return true;\n    }\n    try {\n      const auditEntry = {\n        ...auditData,\n        user_id: this.currentUserId || auditData.user_id,\n        session_id: this.sessionId || auditData.session_id,\n        ip_address: await this.getClientIP(),\n        user_agent: navigator.userAgent,\n        page_url: window.location.href,\n        created_at: new Date().toISOString(),\n        metadata: {\n          ...auditData.metadata,\n          timestamp: Date.now(),\n          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n          screen_resolution: `${window.screen.width}x${window.screen.height}`,\n          viewport_size: `${window.innerWidth}x${window.innerHeight}`\n        }\n      };\n      const {\n        error\n      } = await supabase.from('audit_logs').insert(auditEntry);\n      if (error) {\n        console.warn('Audit logging error (database may not be set up):', error.message);\n        // Don't fail the application if audit logging fails\n        return true;\n      }\n      return true;\n    } catch (error) {\n      console.error('Audit trail error:', error);\n      return false;\n    }\n  }\n\n  // User Activity Logging\n  static async logUserActivity(actionType, actionDetails, metadata) {\n    return this.logAuditEvent({\n      action_type: actionType,\n      action_details: actionDetails,\n      metadata\n    });\n  }\n\n  // Navigation Tracking\n  static async logNavigation(fromPath, toPath, metadata) {\n    return this.logAuditEvent({\n      action_type: 'navigate',\n      action_details: `Navigation from ${fromPath} to ${toPath}`,\n      metadata: {\n        ...metadata,\n        from_path: fromPath,\n        to_path: toPath,\n        navigation_type: 'route_change'\n      }\n    });\n  }\n\n  // Request-specific Logging\n  static async logRequestAction(requestId, actionType, actionDetails, previousStage, newStage, previousStatus, newStatus, amountInvolved, metadata) {\n    return this.logAuditEvent({\n      request_id: requestId,\n      action_type: actionType,\n      action_details: actionDetails,\n      previous_stage: previousStage,\n      new_stage: newStage,\n      previous_status: previousStatus,\n      new_status: newStatus,\n      amount_involved: amountInvolved,\n      metadata\n    });\n  }\n\n  // Data Access Logging\n  static async logDataAccess(dataType, accessType, recordId, metadata) {\n    // Map access types to valid audit action types\n    const actionTypeMap = {\n      'view': 'view',\n      'create': 'create',\n      'update': 'update',\n      'delete': 'update' // Map delete to update since it's not in our enum\n    };\n    return this.logAuditEvent({\n      action_type: actionTypeMap[accessType] || 'view',\n      action_details: `${accessType.toUpperCase()} access to ${dataType}${recordId ? ` (ID: ${recordId})` : ''}`,\n      metadata: {\n        ...metadata,\n        data_type: dataType,\n        access_type: accessType,\n        record_id: recordId\n      }\n    });\n  }\n\n  // Security Event Logging\n  static async logSecurityEvent(eventType, details, metadata) {\n    return this.logAuditEvent({\n      action_type: 'view',\n      // Using 'view' as base type for security events\n      action_details: `SECURITY EVENT: ${eventType} - ${details}`,\n      metadata: {\n        ...metadata,\n        security_event: true,\n        event_type: eventType,\n        severity: 'high'\n      }\n    });\n  }\n\n  // Error Logging\n  static async logError(errorType, errorMessage, stackTrace, metadata) {\n    return this.logAuditEvent({\n      action_type: 'view',\n      // Using 'view' as base type for error events\n      action_details: `ERROR: ${errorType} - ${errorMessage}`,\n      metadata: {\n        ...metadata,\n        error_event: true,\n        error_type: errorType,\n        error_message: errorMessage,\n        stack_trace: stackTrace,\n        severity: 'error'\n      }\n    });\n  }\n\n  // Performance Logging\n  static async logPerformanceMetric(metricName, value, unit, metadata) {\n    return this.logAuditEvent({\n      action_type: 'view',\n      // Using 'view' as base type for performance events\n      action_details: `PERFORMANCE: ${metricName} = ${value}${unit}`,\n      metadata: {\n        ...metadata,\n        performance_metric: true,\n        metric_name: metricName,\n        metric_value: value,\n        metric_unit: unit\n      }\n    });\n  }\n\n  // Session Management\n  static async logSessionEnd(reason) {\n    const result = await this.logUserActivity('logout', `Session ended: ${reason}`, {\n      session_end_reason: reason,\n      session_duration: this.getSessionDuration()\n    });\n\n    // Clear session data\n    this.currentUserId = null;\n    this.sessionId = null;\n    return result;\n  }\n\n  // Utility Methods\n  static async getClientIP() {\n    try {\n      // In production, this would be handled by the backend\n      // For now, we'll use a placeholder\n      return 'client-ip-placeholder';\n    } catch {\n      return 'unknown';\n    }\n  }\n  static getSessionDuration() {\n    // Calculate session duration in minutes\n    const sessionStart = localStorage.getItem('adfd-session-start');\n    if (sessionStart) {\n      return Math.floor((Date.now() - parseInt(sessionStart)) / 60000);\n    }\n    return 0;\n  }\n  static setupPageVisibilityListener() {\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        this.logUserActivity('view', 'Page became hidden/inactive');\n      } else {\n        this.logUserActivity('view', 'Page became visible/active');\n      }\n    });\n  }\n  static setupBeforeUnloadListener() {\n    window.addEventListener('beforeunload', () => {\n      // Use sendBeacon for reliable logging on page unload\n      if (navigator.sendBeacon && this.currentUserId) {\n        const auditData = {\n          user_id: this.currentUserId,\n          action_type: 'logout',\n          action_details: 'Page unload detected',\n          session_id: this.sessionId,\n          created_at: new Date().toISOString()\n        };\n        try {\n          navigator.sendBeacon(`${process.env.REACT_APP_SUPABASE_URL}/rest/v1/audit_logs`, JSON.stringify(auditData));\n        } catch (error) {\n          // Silently fail on page unload\n          console.warn('Failed to send beacon on page unload');\n        }\n      }\n    });\n  }\n\n  // Batch Logging for Performance\n\n  static queueAuditEvent(auditData) {\n    this.auditQueue.push(auditData);\n    if (this.batchTimeout) {\n      clearTimeout(this.batchTimeout);\n    }\n    this.batchTimeout = setTimeout(() => {\n      this.flushAuditQueue();\n    }, 5000); // Flush every 5 seconds\n  }\n  static async flushAuditQueue() {\n    if (this.auditQueue.length === 0) return;\n    const batch = [...this.auditQueue];\n    this.auditQueue = [];\n    try {\n      const {\n        error\n      } = await supabase.from('audit_logs').insert(batch);\n      if (error) {\n        console.error('Batch audit logging error:', error);\n        // Re-queue failed items\n        this.auditQueue.unshift(...batch);\n      }\n    } catch (error) {\n      console.error('Batch audit flush error:', error);\n      // Re-queue failed items\n      this.auditQueue.unshift(...batch);\n    }\n  }\n}\nAuditTrailService.sessionId = null;\nAuditTrailService.currentUserId = null;\nAuditTrailService.auditQueue = [];\nAuditTrailService.batchTimeout = null;","map":{"version":3,"names":["supabase","AuditTrailService","initialize","userId","sessionId","currentUserId","logUserActivity","session_id","login_timestamp","Date","toISOString","setupPageVisibilityListener","setupBeforeUnloadListener","logAuditEvent","auditData","process","env","NODE_ENV","console","log","action_type","action_details","auditEntry","user_id","ip_address","getClientIP","user_agent","navigator","userAgent","page_url","window","location","href","created_at","metadata","timestamp","now","timezone","Intl","DateTimeFormat","resolvedOptions","timeZone","screen_resolution","screen","width","height","viewport_size","innerWidth","innerHeight","error","from","insert","warn","message","actionType","actionDetails","logNavigation","fromPath","toPath","from_path","to_path","navigation_type","logRequestAction","requestId","previousStage","newStage","previousStatus","newStatus","amountInvolved","request_id","previous_stage","new_stage","previous_status","new_status","amount_involved","logDataAccess","dataType","accessType","recordId","actionTypeMap","toUpperCase","data_type","access_type","record_id","logSecurityEvent","eventType","details","security_event","event_type","severity","logError","errorType","errorMessage","stackTrace","error_event","error_type","error_message","stack_trace","logPerformanceMetric","metricName","value","unit","performance_metric","metric_name","metric_value","metric_unit","logSessionEnd","reason","result","session_end_reason","session_duration","getSessionDuration","sessionStart","localStorage","getItem","Math","floor","parseInt","document","addEventListener","hidden","sendBeacon","REACT_APP_SUPABASE_URL","JSON","stringify","queueAuditEvent","auditQueue","push","batchTimeout","clearTimeout","setTimeout","flushAuditQueue","length","batch","unshift"],"sources":["/Users/mamadouourydiallo/ADFI/src/lib/auditTrail.ts"],"sourcesContent":["import { supabase } from './supabase';\nimport { AuditLog } from './database';\n\n// Audit Trail Service for comprehensive logging\nexport class AuditTrailService {\n  private static sessionId: string | null = null;\n  private static currentUserId: string | null = null;\n\n  // Initialize audit trail for user session\n  static initialize(userId: string, sessionId: string) {\n    this.currentUserId = userId;\n    this.sessionId = sessionId;\n    \n    // Log session start\n    this.logUserActivity('login', 'User logged into the system', {\n      session_id: sessionId,\n      login_timestamp: new Date().toISOString()\n    });\n\n    // Set up page visibility change listener\n    this.setupPageVisibilityListener();\n    \n    // Set up beforeunload listener for logout tracking\n    this.setupBeforeUnloadListener();\n  }\n\n  // Core audit logging method\n  static async logAuditEvent(auditData: Partial<AuditLog>): Promise<boolean> {\n    // Temporarily disable audit logging until database is set up\n    if (process.env.NODE_ENV === 'development') {\n      console.log('üîç Audit event (disabled):', auditData.action_type, auditData.action_details);\n      return true;\n    }\n\n    try {\n      const auditEntry: Partial<AuditLog> = {\n        ...auditData,\n        user_id: this.currentUserId || auditData.user_id,\n        session_id: this.sessionId || auditData.session_id,\n        ip_address: await this.getClientIP(),\n        user_agent: navigator.userAgent,\n        page_url: window.location.href,\n        created_at: new Date().toISOString(),\n        metadata: {\n          ...auditData.metadata,\n          timestamp: Date.now(),\n          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n          screen_resolution: `${window.screen.width}x${window.screen.height}`,\n          viewport_size: `${window.innerWidth}x${window.innerHeight}`\n        }\n      };\n\n      const { error } = await supabase\n        .from('audit_logs')\n        .insert(auditEntry);\n\n      if (error) {\n        console.warn('Audit logging error (database may not be set up):', error.message);\n        // Don't fail the application if audit logging fails\n        return true;\n      }\n\n      return true;\n    } catch (error) {\n      console.error('Audit trail error:', error);\n      return false;\n    }\n  }\n\n  // User Activity Logging\n  static async logUserActivity(\n    actionType: AuditLog['action_type'], \n    actionDetails: string, \n    metadata?: Record<string, any>\n  ): Promise<boolean> {\n    return this.logAuditEvent({\n      action_type: actionType,\n      action_details: actionDetails,\n      metadata\n    });\n  }\n\n  // Navigation Tracking\n  static async logNavigation(fromPath: string, toPath: string, metadata?: Record<string, any>): Promise<boolean> {\n    return this.logAuditEvent({\n      action_type: 'navigate',\n      action_details: `Navigation from ${fromPath} to ${toPath}`,\n      metadata: {\n        ...metadata,\n        from_path: fromPath,\n        to_path: toPath,\n        navigation_type: 'route_change'\n      }\n    });\n  }\n\n  // Request-specific Logging\n  static async logRequestAction(\n    requestId: number,\n    actionType: AuditLog['action_type'],\n    actionDetails: string,\n    previousStage?: string,\n    newStage?: string,\n    previousStatus?: string,\n    newStatus?: string,\n    amountInvolved?: number,\n    metadata?: Record<string, any>\n  ): Promise<boolean> {\n    return this.logAuditEvent({\n      request_id: requestId,\n      action_type: actionType,\n      action_details: actionDetails,\n      previous_stage: previousStage,\n      new_stage: newStage,\n      previous_status: previousStatus,\n      new_status: newStatus,\n      amount_involved: amountInvolved,\n      metadata\n    });\n  }\n\n  // Data Access Logging\n  static async logDataAccess(\n    dataType: string,\n    accessType: 'view' | 'create' | 'update' | 'delete',\n    recordId?: string | number,\n    metadata?: Record<string, any>\n  ): Promise<boolean> {\n    // Map access types to valid audit action types\n    const actionTypeMap: Record<string, AuditLog['action_type']> = {\n      'view': 'view',\n      'create': 'create',\n      'update': 'update',\n      'delete': 'update' // Map delete to update since it's not in our enum\n    };\n\n    return this.logAuditEvent({\n      action_type: actionTypeMap[accessType] || 'view',\n      action_details: `${accessType.toUpperCase()} access to ${dataType}${recordId ? ` (ID: ${recordId})` : ''}`,\n      metadata: {\n        ...metadata,\n        data_type: dataType,\n        access_type: accessType,\n        record_id: recordId\n      }\n    });\n  }\n\n  // Security Event Logging\n  static async logSecurityEvent(\n    eventType: 'unauthorized_access' | 'permission_denied' | 'suspicious_activity' | 'password_change',\n    details: string,\n    metadata?: Record<string, any>\n  ): Promise<boolean> {\n    return this.logAuditEvent({\n      action_type: 'view', // Using 'view' as base type for security events\n      action_details: `SECURITY EVENT: ${eventType} - ${details}`,\n      metadata: {\n        ...metadata,\n        security_event: true,\n        event_type: eventType,\n        severity: 'high'\n      }\n    });\n  }\n\n  // Error Logging\n  static async logError(\n    errorType: string,\n    errorMessage: string,\n    stackTrace?: string,\n    metadata?: Record<string, any>\n  ): Promise<boolean> {\n    return this.logAuditEvent({\n      action_type: 'view', // Using 'view' as base type for error events\n      action_details: `ERROR: ${errorType} - ${errorMessage}`,\n      metadata: {\n        ...metadata,\n        error_event: true,\n        error_type: errorType,\n        error_message: errorMessage,\n        stack_trace: stackTrace,\n        severity: 'error'\n      }\n    });\n  }\n\n  // Performance Logging\n  static async logPerformanceMetric(\n    metricName: string,\n    value: number,\n    unit: string,\n    metadata?: Record<string, any>\n  ): Promise<boolean> {\n    return this.logAuditEvent({\n      action_type: 'view', // Using 'view' as base type for performance events\n      action_details: `PERFORMANCE: ${metricName} = ${value}${unit}`,\n      metadata: {\n        ...metadata,\n        performance_metric: true,\n        metric_name: metricName,\n        metric_value: value,\n        metric_unit: unit\n      }\n    });\n  }\n\n  // Session Management\n  static async logSessionEnd(reason: 'logout' | 'timeout' | 'forced'): Promise<boolean> {\n    const result = await this.logUserActivity('logout', `Session ended: ${reason}`, {\n      session_end_reason: reason,\n      session_duration: this.getSessionDuration()\n    });\n\n    // Clear session data\n    this.currentUserId = null;\n    this.sessionId = null;\n\n    return result;\n  }\n\n  // Utility Methods\n  private static async getClientIP(): Promise<string> {\n    try {\n      // In production, this would be handled by the backend\n      // For now, we'll use a placeholder\n      return 'client-ip-placeholder';\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  private static getSessionDuration(): number {\n    // Calculate session duration in minutes\n    const sessionStart = localStorage.getItem('adfd-session-start');\n    if (sessionStart) {\n      return Math.floor((Date.now() - parseInt(sessionStart)) / 60000);\n    }\n    return 0;\n  }\n\n  private static setupPageVisibilityListener(): void {\n    document.addEventListener('visibilitychange', () => {\n      if (document.hidden) {\n        this.logUserActivity('view', 'Page became hidden/inactive');\n      } else {\n        this.logUserActivity('view', 'Page became visible/active');\n      }\n    });\n  }\n\n  private static setupBeforeUnloadListener(): void {\n    window.addEventListener('beforeunload', () => {\n      // Use sendBeacon for reliable logging on page unload\n      if (navigator.sendBeacon && this.currentUserId) {\n        const auditData = {\n          user_id: this.currentUserId,\n          action_type: 'logout' as const,\n          action_details: 'Page unload detected',\n          session_id: this.sessionId,\n          created_at: new Date().toISOString()\n        };\n\n        try {\n          navigator.sendBeacon(\n            `${process.env.REACT_APP_SUPABASE_URL}/rest/v1/audit_logs`,\n            JSON.stringify(auditData)\n          );\n        } catch (error) {\n          // Silently fail on page unload\n          console.warn('Failed to send beacon on page unload');\n        }\n      }\n    });\n  }\n\n  // Batch Logging for Performance\n  private static auditQueue: Partial<AuditLog>[] = [];\n  private static batchTimeout: NodeJS.Timeout | null = null;\n\n  static queueAuditEvent(auditData: Partial<AuditLog>): void {\n    this.auditQueue.push(auditData);\n\n    if (this.batchTimeout) {\n      clearTimeout(this.batchTimeout);\n    }\n\n    this.batchTimeout = setTimeout(() => {\n      this.flushAuditQueue();\n    }, 5000); // Flush every 5 seconds\n  }\n\n  private static async flushAuditQueue(): Promise<void> {\n    if (this.auditQueue.length === 0) return;\n\n    const batch = [...this.auditQueue];\n    this.auditQueue = [];\n\n    try {\n      const { error } = await supabase\n        .from('audit_logs')\n        .insert(batch);\n\n      if (error) {\n        console.error('Batch audit logging error:', error);\n        // Re-queue failed items\n        this.auditQueue.unshift(...batch);\n      }\n    } catch (error) {\n      console.error('Batch audit flush error:', error);\n      // Re-queue failed items\n      this.auditQueue.unshift(...batch);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}